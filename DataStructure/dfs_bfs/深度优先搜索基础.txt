// 选取排列问题 （1~n选r个数字 ， 从小到大排列，打印所有情况 ）
#include <iostream>

using namespace std;
int a[10];

void dfs(int n , int r , int t ){

    a[0] = 0;

    if (t > r){
        for (int i = 1; i <= r; ++i) {
            cout << a[i] << " " ;
        }
        cout << endl;
        return;
    }

    for (int i = 1; i <= n; ++i) {
        a[t] = i;
        if (a[t] > a[t-1])
        {
            dfs( n , r ,t+1 );
        }
    }
}

int main(){

    int n , r;
    cin >> n >> r;
    dfs(n , r , 1);

}


// 素数环问题
#include <iostream>

using namespace std;

int a[100];
int n = 0;
bool b[100];

bool isPrime(int a ){

    for (int i = 2 ; i < a; ++i) {
        if(a%i == 0 || a ==2){
            return false;
        }
    }
    return true;

}

void dfs(int step ){

    if (step > n){
        if (isPrime(a[1] + a[n])){
            for (int i = 0; i < n; ++i){
                cout << a[i+1] << " ";
            }
            cout << endl;
        }
        return;
    }

    for (int i = 1; i <= n; ++i){
        if( step == 1 || (isPrime(a[step-1]+i) && b[i] == 0) ){
            a[step] = i;
            b[i] = 1;
            dfs(step+1 );
            b[i] = 0;
        }
    }
}

int main(){
    a[0] = 0;
    cin >> n;
    dfs(1);
}
	
	
	
	class Solution {
public:
    int maximumDifference(vector<int>& nums) {
        int len = nums.size();
        int maxN = -1;
        int flag = 0;
        for (int i = 0; i < len-1; i++){
            for (int j = i+1; j < len; j++){
                maxN = (nums[j]-nums[i] > maxN) && (nums[j]-nums[i] > 0) ? nums[j]-nums[i] : maxN; 
            }
        }
        return maxN;
    }
};

