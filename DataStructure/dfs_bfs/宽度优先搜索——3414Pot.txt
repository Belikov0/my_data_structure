#include <iostream>
#include <queue>

using namespace std;
int times = 0;
int flag = 0;
int vis[20000][20000];

struct Pot{
    int volume;
    int cur;
    
    Pot() : volume(0), cur(0) {}
    Pot(int a) : volume(a), cur(0) {}

};

struct TwoPots{
    Pot A;
    Pot B;
    int times; 
    int action;
    TwoPots* parent;
    TwoPots* son;
    
    TwoPots() : times(0), action(6), parent(NULL), son(NULL) {}
    TwoPots(int a) : times(0), action(a), parent(NULL), son(NULL) {}
    TwoPots(Pot a, Pot b, int t, int act) : A(a), B(b), times(t), action(act), parent(NULL), son(NULL) {}
};

TwoPots* root;

const char* act[8] = {
        "DROP(1)",  
        "DROP(2)",
        "POUR(1,2)",
        "POUR(2,1)",
        "FILL(1)",
        "FILL(2)",
        "", //
        "impossible"  //
};

void POUR(Pot& A, Pot& B){  // pour A to B
    if (A.cur <= (B.volume-B.cur)){
        B.cur += A.cur;
        A.cur = 0;
    }
    else if (A.cur > (B.volume-B.cur)){
        A.cur = A.cur - (B.volume-B.cur);
        B.cur = B.volume;
    }
}

void DROP(Pot& M){
    M.cur = 0;
}

void FILL(Pot& M){
    M.cur = M.volume;
}

//1 to 6 is corresponding to 6 operations
void bfs_dir(int i, TwoPots* now, int C, queue<TwoPots*>& que){
    Pot A = now->A;
    Pot B = now->B;

    switch (i) {
        case 0:
            if (A.cur != 0)
                DROP(A);
            break;
        case 1:
            if (B.cur != 0)
                DROP(B);
            break;
        case 2:
            if (A.cur != 0 && B.cur != B.volume)
                POUR(A, B);
            break;
        case 3:
            if (B.cur != 0 && A.cur != A.volume)
                POUR(B, A);
            break;
        case 4:
            if (A.cur != A.volume)
                FILL(A);
            break;
        case 5:
            if (B.cur != B.volume)
                FILL(B);
            break;
        default:
            break;
    }

    if (vis[A.cur][B.cur] != 0 )
        return; // condition cut branch

    TwoPots* next = new TwoPots(A, B, now->times + 1, i);
    que.push(next);
    next->parent = now;


    if (A.cur == C || B.cur == C){
        flag = 1;
        times = next->times;
        while(next->parent){ // to get the start point 
            next->parent->son = next;
            next = next->parent;
        }
        root = next;
//        root->action = 6;
        return;
    }

    vis[A.cur][B.cur] = vis[now->A.cur][now->B.cur] + 1;
}

void bfs (int A, int B, int C){

    queue<TwoPots*> que;
    Pot pot_A(A), pot_B(B);
    TwoPots* T = new TwoPots(pot_A, pot_B, 0, 6);
    que.push(T);

    while (!que.empty()){
        TwoPots* cur = que.front();
        que.pop();

        for (int i = 0; i < 6; ++i) {
            bfs_dir(i, cur, C, que);

            if (flag == 1){
                return;
            }
        }
    }
    root = new TwoPots(7); // means impossible
}

void outPut(TwoPots* pots){
    while(pots){
        cout << act[pots->action] << endl;
        pots = pots->son;
    }
}

int main (){
    int A, B, C;
    cin >> A >> B >> C;
    bfs(A, B, C);

    if (times)
        cout << times;
    outPut(root);
    return  0;
}
